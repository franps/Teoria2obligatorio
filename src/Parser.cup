package lang.parser;

import java.io.*;
import java.util.*;
import java_cup.runtime.Symbol;

parser code {:

	
	public static Lexer makeLexer(String input) throws Exception {
		return new Lexer(new StringReader(input));
	}
	
	public static Parser makeParser(String input) throws Exception {
		return new Parser(makeLexer(input));
	}
	
	public static Object parseString(String input) throws Exception {
		Parser parser = Parser.makeParser(input);
		Symbol result = parser.parse();
		return result.value; 
	}
	
:}

// Rules Data 
terminal ROOT, L_BRACKET, R_BRACKET, CONCAT, UNION, DIFFERENCE, INTERSECT, SLASH, DOT,TILDE;
terminal String IDS, STRING;
non terminal Expression QQuery;
non terminal QObject Qobject;
non terminal Expression expression;
precedence left UNION, CONCAT, DIFFERENCE, INTERSECT;
precedence left TILDE, SLASH, DOT;


//Consultas
QQuery ::= ROOT expression:e
  			{: RESULT = e; :} 
  		| ROOT
  		{: RESULT = new Expression(Singleton.getData(), null); :} 
		;

expression ::= L_BRACKET expression:e R_BRACKET
			{: RESULT = e; :} 
		| expression:e1 CONCAT expression:e2
			{: RESULT = new Expression(); RESULT.concat(e1,e2); :}
		| expression:e1 UNION expression:e2
			{: RESULT = new Expression(); RESULT.union(e1,e2); :}
		| expression:e1 DIFFERENCE expression:e2
			{: RESULT = new Expression(); RESULT.difference(e1,e2); :}
		| expression:e1 INTERSECT expression:e2
			{: RESULT = new Expression(); RESULT.intersect(e1,e2); :}
		| expression:e SLASH
			{: RESULT = new Expression(); RESULT.slash(e); :} 
		| expression:e DOT
			{: RESULT = new Expression(); RESULT.dot(e); :}
		| expression:e IDS:s
			{: RESULT = new Expression(); RESULT.searchTag(e, s); :} 
		| expression:e TILDE IDS:s  //Agregar para que soprte cosas que no esten entre comillas
			{: RESULT = new Expression(); RESULT.searchRegex(e, s); :}
		| Qobject:qo
			{: RESULT = new Expression(); RESULT.addQobjects(qo); :} 
		;