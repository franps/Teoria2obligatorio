package lang.parser;

import java.io.*;
import java.util.*;
import java_cup.runtime.Symbol;

parser code {:

	
	public static Lexer makeLexer(String input) throws Exception {
		return new Lexer(new StringReader(input));
	}
	
	public static Parser makeParser(String input) throws Exception {
		return new Parser(makeLexer(input));
	}
	
	public static Object parseString(String input) throws Exception {
		Parser parser = Parser.makeParser(input);
		Symbol result = parser.parse();
		return result.value; 
	}
	
:}
// Rules Consultas


non terminal QObject QObject, QComponents;
non terminal Expression QProgram;
non terminal ArrayList QElement;
non terminal Map<String,Object> QAttribute;
non terminal Object Value;
terminal COMMA, COLON, NULL;
terminal String IDS;
terminal Boolean TRUE, FALSE;
terminal Double DOUBLE;

//PARTE 2
// Rules Data 
terminal ROOT, L_BRACKET, R_BRACKET, CONCAT, UNION, DIFFERENCE, INTERSECT, SLASH, DOT,VIBORA;
terminal String STRING;
non terminal Expression QQuery;
non terminal Expression expression;
precedence left UNION, CONCAT, DIFFERENCE, INTERSECT;
precedence left IDS, VIBORA, SLASH, DOT;

//PARTE 1





//Data
QProgram ::= QObject:q
  			{:	RESULT = new Expression(q); Singleton.setRootData(q); :}
  			| QQuery:q
  			{:	RESULT = q; :}
  		;
  		

QObject ::= IDS:t L_BRACKET QComponents:qes R_BRACKET
  			{: RESULT = qes;  RESULT.setTag(t);:}
  			| IDS:t L_BRACKET R_BRACKET
  			{:RESULT = new QObject(); RESULT.setTag(t); :}
  		;
  
QComponents ::= QElement:qe
  		{: RESULT = new QObject(); RESULT.setElements(qe); :}
  		| QAttribute:qa
  			{: RESULT = new QObject(); RESULT.setAttributes(qa);  :}
  		| QElement:qe COMMA QComponents:qc
  			{:  RESULT=qc; RESULT.addElements(qe);  :}
  		| QAttribute:qa COMMA QComponents:qc
  			{:  RESULT=qc; RESULT.addAttributes(qa); :}
  		;
  				
QElement ::= Value:v //Arreglar que no tome otros valores como string
			{: RESULT = new ArrayList(); RESULT.add(v); :}	   
		;
QAttribute ::=  IDS:s COLON Value:v 
  			{: RESULT = new HashMap<String, Object>(); 
				RESULT.put(s,v); :} 
		;
		
				
Value ::= TRUE:t
			{: RESULT = t; :}  
		| FALSE:f
			{: RESULT = f; :}
		| DOUBLE:d
		  	{: RESULT = d; :}  
		| STRING:s
		  	{: RESULT = s; :}  
		| NULL
		  	{: RESULT = null; :}
		| QObject:qo
  			{: RESULT = qo;  :} 
		;


//FIN PARTE 1
//Consultas
QQuery ::= expression:e
  			{: RESULT = e; :} 
		;

expression ::= L_BRACKET expression:e R_BRACKET
			{: RESULT = e; :} 
		| expression:e1 CONCAT expression:e2
			{: System.out.println("contact");RESULT = new Expression(); RESULT.concat(e1,e2); :}
		| expression:e1 UNION expression:e2
			{: System.out.println("union");RESULT = new Expression(); RESULT.union(e1,e2); :}
		| expression:e1 DIFFERENCE expression:e2
			{: System.out.println("difference");RESULT = new Expression(); RESULT.difference(e1,e2); :}
		| expression:e1 INTERSECT expression:e2
			{: System.out.println("intersect");RESULT = new Expression(); RESULT.intersect(e1,e2); :}
		|expression:e1 SLASH
			{:System.out.println("slash"); RESULT = new Expression(); RESULT.slash(e1); :} 
		|expression:e1 DOT
			{: System.out.println("dot");RESULT = new Expression(); RESULT.dot(e1); :} 
		| expression:e1  IDS:s
			{: System.out.println("ids");RESULT = new Expression(); RESULT.searchTag(e1, s); :} 
		| SLASH
			{: RESULT = new Expression(); RESULT.slash(Singleton.getRootData()); :} 
		|  DOT
			{: RESULT = new Expression(); RESULT.dot(Singleton.getRootData()); :}
		|  ROOT
			{: RESULT =Singleton.getRootData(); :}
		|  IDS:s
			{: System.out.println("ids3");RESULT = new Expression(); RESULT.searchTag(Singleton.getRootData(), s); :} 
		| expression:e VIBORA IDS:s  //Agregar para que soprte cosas que no esten entre comillas
			{: RESULT = new Expression(); RESULT.searchRegex(e, s); :}
		;